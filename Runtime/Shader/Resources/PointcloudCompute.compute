#pragma kernel CreatePointcloud
//#pragma kernel CleanupPointcloud


//Graphics Buffer
ByteAddressBuffer _PointSourceBuffer;
RWByteAddressBuffer _VertexBuffer;
RWByteAddressBuffer _IndexBuffer;

StructuredBuffer<float4x4> _RotateToCamera;

float _PointScale;
int _PointCount;

struct _PointQuad
{
    float3 vertex1;
    float3 vertex2;
    float3 vertex3;
    float3 vertex4;

    uint3 triangle1;
    uint3 triangle2;
    
    float2 uv1;
    float2 uv2;
    float2 uv3;
    float2 uv4;
};

float3 GetPositionFromPointSourceBuffer(int id)
{
    //We access the raw vertex buffer of the mesh vertices. As this buffer is raw, we don't have a handy struct to navigate it
	//and need to find the memory addresses ourselves. As we create the mesh ourselves, we know that we have:
	//Vertex = float3 position (3 floats) + unorm8 vertexcolor (1 uint) = 4 * 4 bytes per vertex
    uint pointIndex = id.x * 4 * 4;

	//All values in the Raw vertex buffer can only be retrieved as ints
    uint3 positionRaw = _PointSourceBuffer.Load3(pointIndex);

	//Reinterpret the int position into floats
    return asfloat(positionRaw);
}

uint GetColorFromPointSourceBuffer(int id)
{
    uint pointIndex = id.x * 4 * 4 + 12;
    return _PointSourceBuffer.Load(pointIndex);
}

_PointQuad RotateQuad(_PointQuad quad, float4x4 rotationMat)
{;
    quad.vertex1 = mul(rotationMat, float4(quad.vertex1, 1.0)).xyz;
    quad.vertex2 = mul(rotationMat, float4(quad.vertex2, 1.0)).xyz;
    quad.vertex3 = mul(rotationMat, float4(quad.vertex3, 1.0)).xyz;
    quad.vertex4 = mul(rotationMat, float4(quad.vertex4, 1.0)).xyz;
    return quad;
}

_PointQuad TranslateQuad(_PointQuad quad, float3 position)
{
    quad.vertex1 = quad.vertex1 + position;
    quad.vertex2 = quad.vertex2 + position;
    quad.vertex3 = quad.vertex3 + position;
    quad.vertex4 = quad.vertex4 + position;
    return quad;
}

_PointQuad CreateQuad(float3 pos, int id, float scale)
{
    //Create a quad
    _PointQuad outQuad = { float3(scale, scale, 0), float3(-scale, scale, 0), float3(-scale, -scale, 0), float3(scale, -scale, 0), uint3(0, 0, 0), uint3(0, 0, 0), float2(0, 0), float2(0, 0), float2(0, 0), float2(0,0) };
    
    //First rotate the point to face the camera
    outQuad = RotateQuad(outQuad, _RotateToCamera[0]);
    
    //Then position it according to source array
    outQuad = TranslateQuad(outQuad, pos);
       
    //Create our faces. We indice from the top right corner in an anti-clockwise direction
    uint i = id * 4;
    outQuad.triangle1 = uint3(2 + i, 1 + i, 0 + i);
    outQuad.triangle2 = uint3(0 + i, 3 + i, 2 + i);
    
    //Create UV coordinates
    outQuad.uv1 = float2(1, 1);
    outQuad.uv2 = float2(-1, 1);
    outQuad.uv3 = float2(-1, -1);
    outQuad.uv4 = float2(1, -1);
    
    return outQuad;
}


void StoreQuad(_PointQuad quad, uint color, int id)
{
    //The vertex buffer position for a quad is: Thread ID * 4 (vertices per quad) * 3 (floats per vertice posiion) * 2 (floats per UV) + 1 (uint for color))
    uint vBufferPos = (id * 4 * (3 + 2 + 1));

    
    //Add offset for each vertex + vertexcolor and then multiply by amount of bytes per float (4) to get the final byte adress
    uint vPos1 = (vBufferPos + 0) * 4;
    uint cPos1 = (vBufferPos + 3) * 4;
    uint tPos1 = (vBufferPos + 4) * 4;
    
    uint vPos2 = (vBufferPos + 6) * 4;
    uint cPos2 = (vBufferPos + 9) * 4;
    uint tPos2 = (vBufferPos + 10) * 4;
    
    uint vPos3 = (vBufferPos + 12) * 4;
    uint cPos3 = (vBufferPos + 15) * 4;
    uint tPos3 = (vBufferPos + 16) * 4;

    uint vPos4 = (vBufferPos + 18) * 4;
    uint cPos4 = (vBufferPos + 21) * 4;
    uint tPos4 = (vBufferPos + 22) * 4;;
    
    //The indice buffer byte position for a quad is Thread ID * 2 (indices per quad) * 3 (ints per indice)
    uint iBufferPos = id * 2 * 3;
    
    //Add offset for each indice and then multiply by amount of bytes per uint (4) to get the final byte adress
    uint iPos1 = (iBufferPos + 0) * 4;
    uint iPos2 = (iBufferPos + 3) * 4;
    
    _VertexBuffer.Store3(vPos1, asuint(quad.vertex1));
    _VertexBuffer.Store(cPos1, color);
    _VertexBuffer.Store2(tPos1, asuint(quad.uv1));
    _VertexBuffer.Store3(vPos2, asuint(quad.vertex2));
    _VertexBuffer.Store(cPos2, color);
    _VertexBuffer.Store2(tPos2, asuint(quad.uv2));
    _VertexBuffer.Store3(vPos3, asuint(quad.vertex3));
    _VertexBuffer.Store(cPos3, color);
    _VertexBuffer.Store2(tPos3, asuint(quad.uv3));
    _VertexBuffer.Store3(vPos4, asuint(quad.vertex4));
    _VertexBuffer.Store(cPos4, color);
    _VertexBuffer.Store2(tPos4, asuint(quad.uv4));

    
    _IndexBuffer.Store3(iPos1, quad.triangle1);
    _IndexBuffer.Store3(iPos2, quad.triangle2);
}

[numthreads(128, 1, 1)]
void CreatePointcloud(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_PointCount)        
        return;
    
    float3 position = GetPositionFromPointSourceBuffer(id.x);
    uint color = GetColorFromPointSourceBuffer(id.x);
    
    _PointQuad quad = CreateQuad(position, id.x, _PointScale);
    
    StoreQuad(quad, color, id.x);
}


//Reset position and indices of unused points (in case the actual point count is less than the buffer size)
//[numthreads(128,1,1)]
//void CleanupPointcloud(uint3 id : SV_DispatchThreadID)
//{
//    if (id.x < (uint) _PointCount)
//        return;
    
//    _PointQuad emptyQuad = { float3(0, 0, 0), float3(0, 0, 0), float3(0, 0, 0), float3(0, 0, 0), uint3(0, 0, 0), uint3(0, 0, 0)};
//    StoreQuad(emptyQuad, 0, id.x);
//}

    
    

